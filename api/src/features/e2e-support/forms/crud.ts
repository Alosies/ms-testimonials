import { executeGraphQLAsAdmin } from '@/shared/libs/hasura';
import {
  // Form operations
  CreateTestFormDocument,
  SoftDeleteTestFormDocument,
  CleanupOldTestFormsDocument,
  UpdateFormBranchingConfigDocument,
  // Flow operations
  CreateTestFlowDocument,
  CreateBranchFlowDocument,
  // Step operations
  CreateTestFormStepDocument,
  // Question operations
  CreateTestFormQuestionDocument,
  // Types
  type CreateTestFormMutation,
  type SoftDeleteTestFormMutation,
  type CleanupOldTestFormsMutation,
  type UpdateFormBranchingConfigMutation,
  type CreateTestFlowMutation,
  type CreateBranchFlowMutation,
  type CreateTestFormStepMutation,
  type CreateTestFormQuestionMutation,
} from '@/graphql/generated/operations';
import type { TestQuestion, TestStep, TestFormResult, TestFlow, TestBranchedFormResult } from './types';
import { QUESTION_TYPE_IDS } from './constants';

/**
 * Form CRUD operations for E2E testing
 *
 * Creates and manages test forms with steps and questions.
 * All operations use admin client to bypass RLS.
 * User/org IDs come from environment variables - no DB lookups needed.
 * IDs are generated by the database using generate_nanoid_12().
 */

/**
 * Create a test form with a flow, steps, and questions
 *
 * Creates a complete form structure suitable for E2E testing:
 * - 1 form with "E2E Test Form" prefix
 * - 1 primary flow
 * - 5 steps with different types for comprehensive testing:
 *   - welcome (step_order: 0) - intro screen
 *   - question (step_order: 1) - text input with long text question
 *   - rating (step_order: 2) - star rating question
 *   - contact_info (step_order: 3) - submitter details
 *   - thank_you (step_order: 4) - completion screen
 *
 * IDs are generated by the database (not client-side).
 * Returns full data so tests can use actual values for assertions.
 *
 * @param organizationId - Organization ID (from E2E_ORGANIZATION_ID env var)
 * @param name - Form name (will be prefixed with "E2E Test Form - ")
 * @param createdBy - User ID (from E2E_USER_ID env var)
 * @returns Full form data including steps and questions for test assertions
 */
export async function createTestFormWithSteps(
  organizationId: string,
  name: string,
  createdBy: string
): Promise<TestFormResult> {
  const formName = `E2E Test Form - ${name}`;

  // 1. Create the form (DB generates ID)
  const { data: formData, error: formError } = await executeGraphQLAsAdmin<CreateTestFormMutation>(
    CreateTestFormDocument,
    {
      organization_id: organizationId,
      name: formName,
      status: 'draft',
      created_by: createdBy,
      product_name: 'Test Product',
      product_description: 'A test product for E2E testing',
    }
  );

  if (formError || !formData?.insert_forms_one?.id) {
    throw new Error(`Failed to create test form: ${formError?.message || 'No form ID returned'}`);
  }

  const formId = formData.insert_forms_one.id;

  // 2. Create the primary flow (DB generates ID)
  const { data: flowData, error: flowError } = await executeGraphQLAsAdmin<CreateTestFlowMutation>(
    CreateTestFlowDocument,
    {
      form_id: formId,
      organization_id: organizationId,
      name: 'Main Flow',
      flow_type: 'shared',
      is_primary: true,
      display_order: 0,
    }
  );

  if (flowError || !flowData?.insert_flows_one?.id) {
    throw new Error(`Failed to create test flow: ${flowError?.message || 'No flow ID returned'}`);
  }

  const flowId = flowData.insert_flows_one.id;

  // 3. Create steps (DB generates IDs)
  // 5 steps with different types for comprehensive testing
  const stepConfigs: Array<{
    stepType: TestStep['stepType'];
    stepOrder: number;
    question?: { text: string; key: string; typeId: string };
  }> = [
    { stepType: 'welcome', stepOrder: 0 },
    {
      stepType: 'question',
      stepOrder: 1,
      question: {
        text: 'What challenges did you face before using our product?',
        key: 'challenges',
        typeId: QUESTION_TYPE_IDS.TEXT_LONG,
      },
    },
    {
      stepType: 'rating',
      stepOrder: 2,
      question: {
        text: 'How would you rate your experience?',
        key: 'experience_rating',
        typeId: QUESTION_TYPE_IDS.RATING_STAR,
      },
    },
    { stepType: 'contact_info', stepOrder: 3 },
    { stepType: 'thank_you', stepOrder: 4 },
  ];

  const steps: TestStep[] = [];

  for (const config of stepConfigs) {
    const { data: stepData, error: stepError } = await executeGraphQLAsAdmin<CreateTestFormStepMutation>(
      CreateTestFormStepDocument,
      {
        flow_id: flowId,
        organization_id: organizationId,
        step_type: config.stepType,
        step_order: config.stepOrder,
        is_active: true,
      }
    );

    if (stepError || !stepData?.insert_form_steps_one?.id) {
      throw new Error(`Failed to create test step: ${stepError?.message || 'No step ID returned'}`);
    }

    const stepId = stepData.insert_form_steps_one.id;
    const questions: TestQuestion[] = [];

    // Add question if configured for this step
    if (config.question) {
      const { data: questionData, error: questionError } = await executeGraphQLAsAdmin<CreateTestFormQuestionMutation>(
        CreateTestFormQuestionDocument,
        {
          step_id: stepId,
          organization_id: organizationId,
          question_type_id: config.question.typeId,
          question_text: config.question.text,
          question_key: config.question.key,
          display_order: 1,
          is_required: true,
          is_active: true,
        }
      );

      if (questionError || !questionData?.insert_form_questions_one?.id) {
        throw new Error(`Failed to create test question: ${questionError?.message || 'No question ID returned'}`);
      }

      questions.push({
        id: questionData.insert_form_questions_one.id,
        stepId,
        questionText: config.question.text,
        questionKey: config.question.key,
        questionTypeId: config.question.typeId,
        displayOrder: 1,
        isRequired: true,
      });
    }

    steps.push({
      id: stepId,
      stepType: config.stepType,
      stepOrder: config.stepOrder,
      questions,
    });
  }

  return {
    formId,
    formName,
    flowId,
    steps,
  };
}

/**
 * Create a test form with branching (shared + testimonial + improvement flows)
 *
 * Creates a complete branched form structure for E2E testing that mimics
 * the Taskflow form pattern:
 * - 1 form with "E2E Branched Form" prefix
 * - 1 shared flow with: welcome, 3 questions, rating steps (5 total, rating last)
 * - 1 testimonial flow (rating >= 4) with: question, consent, thank_you steps
 * - 1 improvement flow (rating < 4) with: question, thank_you steps
 *
 * Structure mirrors production form patterns:
 * - Shared flow: welcome(0), problem_before(1), solution_experience(2), specific_results(3), rating(4)
 * - Testimonial flow: recommendation(0), consent(1), thank_you(2)
 * - Improvement flow: improvement_feedback(0), thank_you(1)
 *
 * @param organizationId - Organization ID (from E2E_ORGANIZATION_ID env var)
 * @param name - Form name (will be prefixed with "E2E Branched Form - ")
 * @param createdBy - User ID (from E2E_USER_ID env var)
 * @returns Full branched form data including all flows and steps
 */
export async function createTestFormWithBranching(
  organizationId: string,
  name: string,
  createdBy: string
): Promise<TestBranchedFormResult> {
  const formName = `E2E Branched Form - ${name}`;

  // 1. Create the form
  const { data: formData, error: formError } = await executeGraphQLAsAdmin<CreateTestFormMutation>(
    CreateTestFormDocument,
    {
      organization_id: organizationId,
      name: formName,
      status: 'draft',
      created_by: createdBy,
      product_name: 'Test Product',
      product_description: 'A test product for E2E branching tests',
    }
  );

  if (formError || !formData?.insert_forms_one?.id) {
    throw new Error(`Failed to create test form: ${formError?.message || 'No form ID returned'}`);
  }

  const formId = formData.insert_forms_one.id;

  // 2. Create the shared flow (primary)
  const { data: sharedFlowData, error: sharedFlowError } = await executeGraphQLAsAdmin<CreateTestFlowMutation>(
    CreateTestFlowDocument,
    {
      form_id: formId,
      organization_id: organizationId,
      name: 'Shared Steps',
      flow_type: 'shared',
      is_primary: true,
      display_order: 0,
    }
  );

  if (sharedFlowError || !sharedFlowData?.insert_flows_one?.id) {
    throw new Error(`Failed to create shared flow: ${sharedFlowError?.message || 'No flow ID returned'}`);
  }

  const sharedFlowId = sharedFlowData.insert_flows_one.id;

  // 3. Create shared steps: welcome, 3 questions, rating (5 total, rating last)
  // This mimics the Taskflow form structure
  const sharedSteps: TestStep[] = [];
  let stepOrder = 0;
  let branchQuestionId = '';

  // Welcome step (step_order: 0)
  const welcomeStep = await createStep(sharedFlowId, organizationId, 'welcome', stepOrder++);
  sharedSteps.push({ ...welcomeStep, flowMembership: 'shared', flowId: sharedFlowId });

  // Question step 1: Problem before (step_order: 1)
  const problemStep = await createStep(sharedFlowId, organizationId, 'question', stepOrder++);
  const problemQuestion = await createQuestion(
    problemStep.id,
    organizationId,
    'Before using our product, what challenges did you face?',
    'problem_before',
    QUESTION_TYPE_IDS.TEXT_LONG
  );
  problemStep.questions.push(problemQuestion);
  sharedSteps.push({ ...problemStep, flowMembership: 'shared', flowId: sharedFlowId });

  // Question step 2: Solution experience (step_order: 2)
  const solutionStep = await createStep(sharedFlowId, organizationId, 'question', stepOrder++);
  const solutionQuestion = await createQuestion(
    solutionStep.id,
    organizationId,
    'Can you describe your experience using our product? What features stood out?',
    'solution_experience',
    QUESTION_TYPE_IDS.TEXT_LONG
  );
  solutionStep.questions.push(solutionQuestion);
  sharedSteps.push({ ...solutionStep, flowMembership: 'shared', flowId: sharedFlowId });

  // Question step 3: Specific results (step_order: 3)
  const resultsStep = await createStep(sharedFlowId, organizationId, 'question', stepOrder++);
  const resultsQuestion = await createQuestion(
    resultsStep.id,
    organizationId,
    'What specific results have you seen? Please share any metrics or examples.',
    'specific_results',
    QUESTION_TYPE_IDS.TEXT_LONG
  );
  resultsStep.questions.push(resultsQuestion);
  sharedSteps.push({ ...resultsStep, flowMembership: 'shared', flowId: sharedFlowId });

  // Rating step - branch point (step_order: 4) - LAST step in shared flow
  const ratingStep = await createStep(sharedFlowId, organizationId, 'rating', stepOrder++);
  const ratingQuestion = await createQuestion(
    ratingStep.id,
    organizationId,
    'Overall, how satisfied are you with our product?',
    'rating',
    QUESTION_TYPE_IDS.RATING_STAR
  );
  ratingStep.questions.push(ratingQuestion);
  sharedSteps.push({ ...ratingStep, flowMembership: 'shared', flowId: sharedFlowId });
  branchQuestionId = ratingQuestion.id;

  // Update form's branching_config with enabled=true and ratingStepId
  const { error: branchingConfigError } = await executeGraphQLAsAdmin<UpdateFormBranchingConfigMutation>(
    UpdateFormBranchingConfigDocument,
    {
      id: formId,
      branching_config: {
        enabled: true,
        threshold: 4,
        ratingStepId: ratingStep.id,
      },
    }
  );

  if (branchingConfigError) {
    throw new Error(`Failed to update branching config: ${branchingConfigError.message}`);
  }

  // 4. Create testimonial flow (rating >= 4)
  const { data: testimonialFlowData, error: testimonialFlowError } = await executeGraphQLAsAdmin<CreateBranchFlowMutation>(
    CreateBranchFlowDocument,
    {
      form_id: formId,
      organization_id: organizationId,
      name: 'Testimonial Flow',
      flow_type: 'branch',
      is_primary: false,
      display_order: 1,
      branch_question_id: branchQuestionId,
      branch_field: 'answer_integer',
      branch_operator: 'greater_than_or_equal_to',
      branch_value: { type: 'number', value: 4 },
    }
  );

  if (testimonialFlowError || !testimonialFlowData?.insert_flows_one?.id) {
    throw new Error(`Failed to create testimonial flow: ${testimonialFlowError?.message || 'No flow ID returned'}`);
  }

  const testimonialFlowId = testimonialFlowData.insert_flows_one.id;

  // 5. Create testimonial steps (for rating >= 4)
  const testimonialSteps: TestStep[] = [];
  let testimonialStepOrder = 0;

  // Question step: recommendation (step_order: 0 within testimonial flow)
  const testimonialQuestionStep = await createStep(testimonialFlowId, organizationId, 'question', testimonialStepOrder++, undefined, 'testimonial');
  const testimonialQuestion = await createQuestion(
    testimonialQuestionStep.id,
    organizationId,
    'What would you tell someone considering using our product?',
    'recommendation',
    QUESTION_TYPE_IDS.TEXT_LONG
  );
  testimonialQuestionStep.questions.push(testimonialQuestion);
  testimonialSteps.push({ ...testimonialQuestionStep, flowMembership: 'testimonial', flowId: testimonialFlowId });

  // Consent step (step_order: 1 within testimonial flow)
  const consentStep = await createStep(testimonialFlowId, organizationId, 'consent', testimonialStepOrder++, undefined, 'testimonial');
  testimonialSteps.push({ ...consentStep, flowMembership: 'testimonial', flowId: testimonialFlowId });

  // Thank you step (step_order: 2 within testimonial flow)
  const testimonialThankYouStep = await createStep(testimonialFlowId, organizationId, 'thank_you', testimonialStepOrder++, undefined, 'testimonial');
  testimonialSteps.push({ ...testimonialThankYouStep, flowMembership: 'testimonial', flowId: testimonialFlowId });

  // 6. Create improvement flow (rating < 4)
  const { data: improvementFlowData, error: improvementFlowError } = await executeGraphQLAsAdmin<CreateBranchFlowMutation>(
    CreateBranchFlowDocument,
    {
      form_id: formId,
      organization_id: organizationId,
      name: 'Improvement Flow',
      flow_type: 'branch',
      is_primary: false,
      display_order: 2,
      branch_question_id: branchQuestionId,
      branch_field: 'answer_integer',
      branch_operator: 'less_than',
      branch_value: { type: 'number', value: 4 },
    }
  );

  if (improvementFlowError || !improvementFlowData?.insert_flows_one?.id) {
    throw new Error(`Failed to create improvement flow: ${improvementFlowError?.message || 'No flow ID returned'}`);
  }

  const improvementFlowId = improvementFlowData.insert_flows_one.id;

  // 7. Create improvement steps (for rating < 4)
  const improvementSteps: TestStep[] = [];
  let improvementStepOrder = 0;

  // Question step: improvement feedback (step_order: 0 within improvement flow)
  const improvementQuestionStep = await createStep(improvementFlowId, organizationId, 'question', improvementStepOrder++, undefined, 'improvement');
  const improvementQuestion = await createQuestion(
    improvementQuestionStep.id,
    organizationId,
    'What could we do to improve your experience?',
    'improvement_feedback',
    QUESTION_TYPE_IDS.TEXT_LONG
  );
  improvementQuestionStep.questions.push(improvementQuestion);
  improvementSteps.push({ ...improvementQuestionStep, flowMembership: 'improvement', flowId: improvementFlowId });

  // Thank you step (step_order: 1 within improvement flow) - with different message
  const improvementThankYouStep = await createStep(improvementFlowId, organizationId, 'thank_you', improvementStepOrder++, {
    title: 'Thank you for your honest feedback.',
    subtitle: 'We take your feedback seriously and will use it to improve our product.',
  }, 'improvement');
  improvementSteps.push({ ...improvementThankYouStep, flowMembership: 'improvement', flowId: improvementFlowId });

  // Build result
  const sharedFlow: TestFlow = {
    id: sharedFlowId,
    name: 'Shared Steps',
    flowType: 'shared',
    isPrimary: true,
    displayOrder: 0,
    steps: sharedSteps,
  };

  const testimonialFlow: TestFlow = {
    id: testimonialFlowId,
    name: 'Testimonial Flow',
    flowType: 'branch',
    isPrimary: false,
    displayOrder: 1,
    steps: testimonialSteps,
  };

  const improvementFlow: TestFlow = {
    id: improvementFlowId,
    name: 'Improvement Flow',
    flowType: 'branch',
    isPrimary: false,
    displayOrder: 2,
    steps: improvementSteps,
  };

  return {
    formId,
    formName,
    sharedFlow,
    testimonialFlow,
    improvementFlow,
    allSteps: [...sharedSteps, ...testimonialSteps, ...improvementSteps],
    branchQuestionId,
  };
}

/**
 * Default content for step types that require it
 */
const DEFAULT_STEP_CONTENT: Partial<Record<TestStep['stepType'], object>> = {
  welcome: {
    title: 'Share your experience with us',
    subtitle: 'It only takes a couple of minutes',
    buttonText: 'Get Started',
  },
  consent: {
    title: 'One last thing...',
    description: 'Can we share your feedback?',
    options: {
      public: {
        label: 'Share publicly',
        description: 'Your testimonial may be featured on our website and marketing materials.',
      },
      private: {
        label: 'Keep private',
        description: 'Your feedback will be used internally to improve our product.',
      },
    },
  },
  thank_you: {
    title: 'Thank you!',
    subtitle: 'We really appreciate your feedback',
  },
};

/**
 * Helper: Create a step
 */
async function createStep(
  flowId: string,
  organizationId: string,
  stepType: TestStep['stepType'],
  stepOrder: number,
  contentOverride?: object,
  flowMembership: string = 'shared'
): Promise<TestStep> {
  // Use provided content, or default content for step types that need it
  const content = contentOverride ?? DEFAULT_STEP_CONTENT[stepType] ?? {};

  const { data, error } = await executeGraphQLAsAdmin<CreateTestFormStepMutation>(
    CreateTestFormStepDocument,
    {
      flow_id: flowId,
      organization_id: organizationId,
      step_type: stepType,
      step_order: stepOrder,
      is_active: true,
      content,
      flow_membership: flowMembership,
    }
  );

  if (error || !data?.insert_form_steps_one?.id) {
    throw new Error(`Failed to create step: ${error?.message || 'No step ID returned'}`);
  }

  return {
    id: data.insert_form_steps_one.id,
    stepType,
    stepOrder,
    questions: [],
  };
}

/**
 * Helper: Create a question
 */
async function createQuestion(
  stepId: string,
  organizationId: string,
  questionText: string,
  questionKey: string,
  questionTypeId: string
): Promise<TestQuestion> {
  const { data, error } = await executeGraphQLAsAdmin<CreateTestFormQuestionMutation>(
    CreateTestFormQuestionDocument,
    {
      step_id: stepId,
      organization_id: organizationId,
      question_type_id: questionTypeId,
      question_text: questionText,
      question_key: questionKey,
      display_order: 1,
      is_required: true,
      is_active: true,
    }
  );

  if (error || !data?.insert_form_questions_one?.id) {
    throw new Error(`Failed to create question: ${error?.message || 'No question ID returned'}`);
  }

  return {
    id: data.insert_form_questions_one.id,
    stepId,
    questionText,
    questionKey,
    questionTypeId,
    displayOrder: 1,
    isRequired: true,
  };
}

/**
 * Soft delete a test form by setting is_active to false
 *
 * @param formId - Form ID to soft delete
 * @returns true if form was deleted, false otherwise
 */
export async function deleteTestForm(formId: string): Promise<boolean> {
  const { data, error } = await executeGraphQLAsAdmin<SoftDeleteTestFormMutation>(
    SoftDeleteTestFormDocument,
    { id: formId }
  );

  if (error) {
    console.error('Error deleting test form:', error);
    return false;
  }

  return data?.update_forms_by_pk !== null && data?.update_forms_by_pk?.is_active === false;
}

/**
 * Clean up old E2E test data by soft-deleting forms older than specified hours
 *
 * Only affects forms with names starting with "E2E Test Form"
 *
 * @param organizationId - Organization ID to clean up
 * @param olderThanHours - Delete forms older than this many hours (default: 24)
 * @returns Number of forms soft-deleted
 */
export async function cleanupTestData(
  organizationId: string,
  olderThanHours: number = 24
): Promise<number> {
  const cutoffTime = new Date(Date.now() - olderThanHours * 60 * 60 * 1000).toISOString();

  const { data, error } = await executeGraphQLAsAdmin<CleanupOldTestFormsMutation>(
    CleanupOldTestFormsDocument,
    {
      organization_id: organizationId,
      cutoff_time: cutoffTime,
    }
  );

  if (error) {
    console.error('Error cleaning up test data:', error);
    return 0;
  }

  return data?.update_forms?.affected_rows ?? 0;
}
