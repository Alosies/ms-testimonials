// @ts-nocheck - Generated by Drizzle introspection. Circular FK references cause TS errors but runtime is correct.
import { pgTable, unique, text, varchar, boolean, timestamp, index, integer, foreignKey, check, type AnyPgColumn, uniqueIndex, jsonb, smallint, bigint, numeric, pgEnum } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const organizationSetupStatus = pgEnum("organization_setup_status", ['pending_setup', 'completed'])


export const roles = pgTable("roles", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	uniqueName: varchar("unique_name", { length: 50 }).notNull(),
	name: varchar({ length: 100 }).notNull(),
	description: text(),
	canManageForms: boolean("can_manage_forms").default(false).notNull(),
	canManageTestimonials: boolean("can_manage_testimonials").default(false).notNull(),
	canManageWidgets: boolean("can_manage_widgets").default(false).notNull(),
	canManageMembers: boolean("can_manage_members").default(false).notNull(),
	canManageBilling: boolean("can_manage_billing").default(false).notNull(),
	canDeleteOrg: boolean("can_delete_org").default(false).notNull(),
	isViewer: boolean("is_viewer").default(false).notNull(),
	isSystemRole: boolean("is_system_role").default(false).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("roles_unique_name_unique").on(table.uniqueName),
]);

export const plans = pgTable("plans", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	uniqueName: varchar("unique_name", { length: 50 }).notNull(),
	name: varchar({ length: 100 }).notNull(),
	description: text(),
	maxTestimonials: integer("max_testimonials").notNull(),
	maxForms: integer("max_forms").notNull(),
	maxWidgets: integer("max_widgets").notNull(),
	maxMembers: integer("max_members").notNull(),
	showBranding: boolean("show_branding").default(true).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_plans_active").using("btree", table.id.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
	index("idx_plans_unique_name").using("btree", table.uniqueName.asc().nullsLast().op("text_ops")),
	unique("plans_unique_name_unique").on(table.uniqueName),
]);

export const planPrices = pgTable("plan_prices", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	planId: text("plan_id").notNull(),
	currencyCode: varchar("currency_code", { length: 3 }).default('USD').notNull(),
	priceMonthlyInBaseUnit: integer("price_monthly_in_base_unit").default(0).notNull(),
	priceYearlyInBaseUnit: integer("price_yearly_in_base_unit").default(0).notNull(),
	priceLifetimeInBaseUnit: integer("price_lifetime_in_base_unit"),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_plan_prices_currency").using("btree", table.currencyCode.asc().nullsLast().op("text_ops")),
	index("idx_plan_prices_plan").using("btree", table.planId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.planId],
			foreignColumns: [plans.id],
			name: "plan_prices_plan_fk"
		}).onDelete("cascade"),
	unique("plan_prices_unique").on(table.planId, table.currencyCode),
	check("plan_prices_currency_check", sql`(currency_code)::text ~ '^[A-Z]{3}$'::text`),
]);

export const organizations = pgTable("organizations", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	name: text().notNull(),
	slug: varchar({ length: 100 }).notNull(),
	settings: jsonb().default({}).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdBy: text("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	setupStatus: organizationSetupStatus("setup_status").default('completed').notNull(),
	logoId: text("logo_id"),
}, (table) => [
	index("idx_organizations_active").using("btree", table.id.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
	index("idx_organizations_created_by").using("btree", table.createdBy.asc().nullsLast().op("text_ops")),
	index("idx_organizations_logo_id").using("btree", table.logoId.asc().nullsLast().op("text_ops")),
	uniqueIndex("idx_organizations_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.logoId],
			foreignColumns: [media.id],
			name: "fk_organizations_logo_id"
		}).onUpdate("cascade").onDelete("set null"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "organizations_created_by_fk"
		}).onDelete("set null"),
	unique("organizations_slug_unique").on(table.slug),
	check("organizations_slug_format", sql`(slug)::text ~ '^[a-z0-9]([a-z0-9-]*[a-z0-9])?$'::text`),
]);

export const users = pgTable("users", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	email: text().notNull(),
	emailVerified: boolean("email_verified").default(false).notNull(),
	displayName: text("display_name"),
	avatarUrl: text("avatar_url"),
	locale: text().default('en').notNull(),
	timezone: text().default('UTC').notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	lastLoginAt: timestamp("last_login_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_users_active").using("btree", table.id.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
	index("idx_users_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	unique("users_email_unique").on(table.email),
	check("users_locale_check", sql`locale ~ '^[a-z]{2}(-[A-Z]{2})?$'::text`),
]);

export const userIdentities = pgTable("user_identities", {
	id: text().default(sql`generate_nanoid_16()`).primaryKey().notNull(),
	userId: text("user_id").notNull(),
	provider: text().notNull(),
	providerUserId: text("provider_user_id").notNull(),
	providerEmail: text("provider_email"),
	providerMetadata: jsonb("provider_metadata"),
	isPrimary: boolean("is_primary").default(false).notNull(),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_user_identities_lookup").using("btree", table.provider.asc().nullsLast().op("text_ops"), table.providerUserId.asc().nullsLast().op("text_ops")),
	uniqueIndex("idx_user_identities_one_primary").using("btree", table.userId.asc().nullsLast().op("text_ops")).where(sql`(is_primary = true)`),
	index("idx_user_identities_user").using("btree", table.userId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "user_identities_user_fk"
		}).onDelete("cascade"),
	unique("user_identities_provider_unique").on(table.provider, table.providerUserId),
	check("user_identities_provider_check", sql`provider = ANY (ARRAY['supabase'::text, 'google'::text, 'github'::text, 'microsoft'::text, 'email'::text])`),
]);

export const organizationPlans = pgTable("organization_plans", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	planId: text("plan_id").notNull(),
	status: text().default('active').notNull(),
	billingCycle: text("billing_cycle").notNull(),
	currencyCode: varchar("currency_code", { length: 3 }).default('USD').notNull(),
	startsAt: timestamp("starts_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	currentPeriodEndsAt: timestamp("current_period_ends_at", { withTimezone: true, mode: 'string' }),
	trialEndsAt: timestamp("trial_ends_at", { withTimezone: true, mode: 'string' }),
	cancelledAt: timestamp("cancelled_at", { withTimezone: true, mode: 'string' }),
	maxForms: integer("max_forms").notNull(),
	maxTestimonials: integer("max_testimonials").notNull(),
	maxWidgets: integer("max_widgets").notNull(),
	maxMembers: integer("max_members").notNull(),
	showBranding: boolean("show_branding").notNull(),
	priceInBaseUnit: integer("price_in_base_unit").notNull(),
	hasOverrides: boolean("has_overrides").default(false).notNull(),
	overrideReason: text("override_reason"),
	overriddenBy: text("overridden_by"),
	overriddenAt: timestamp("overridden_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	uniqueIndex("idx_org_plans_active").using("btree", table.organizationId.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['trial'::text, 'active'::text]))`),
	index("idx_org_plans_expiring").using("btree", table.currentPeriodEndsAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((status = 'active'::text) AND (current_period_ends_at IS NOT NULL))`),
	index("idx_org_plans_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_org_plans_plan").using("btree", table.planId.asc().nullsLast().op("text_ops")),
	index("idx_org_plans_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "org_plans_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.overriddenBy],
			foreignColumns: [users.id],
			name: "org_plans_overridden_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.planId],
			foreignColumns: [plans.id],
			name: "org_plans_plan_fk"
		}),
	check("org_plans_billing_check", sql`billing_cycle = ANY (ARRAY['monthly'::text, 'yearly'::text, 'lifetime'::text])`),
	check("org_plans_currency_check", sql`(currency_code)::text ~ '^[A-Z]{3}$'::text`),
	check("org_plans_status_check", sql`status = ANY (ARRAY['trial'::text, 'active'::text, 'cancelled'::text, 'expired'::text])`),
]);

export const organizationRoles = pgTable("organization_roles", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	userId: text("user_id").notNull(),
	organizationId: text("organization_id").notNull(),
	roleId: text("role_id").notNull(),
	isDefaultOrg: boolean("is_default_org").default(false).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	invitedBy: text("invited_by"),
	invitedAt: timestamp("invited_at", { withTimezone: true, mode: 'string' }),
	joinedAt: timestamp("joined_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_org_roles_active").using("btree", table.userId.asc().nullsLast().op("text_ops"), table.organizationId.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
	uniqueIndex("idx_org_roles_one_default").using("btree", table.userId.asc().nullsLast().op("text_ops")).where(sql`(is_default_org = true)`),
	index("idx_org_roles_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_org_roles_role").using("btree", table.roleId.asc().nullsLast().op("text_ops")),
	index("idx_org_roles_user").using("btree", table.userId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.invitedBy],
			foreignColumns: [users.id],
			name: "org_roles_invited_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "org_roles_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.roleId],
			foreignColumns: [roles.id],
			name: "org_roles_role_fk"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "org_roles_user_fk"
		}).onDelete("cascade"),
	unique("org_roles_unique").on(table.userId, table.organizationId),
]);

export const forms = pgTable("forms", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	createdBy: text("created_by").notNull(),
	updatedBy: text("updated_by"),
	name: text().notNull(),
	productName: text("product_name").notNull(),
	productDescription: text("product_description"),
	settings: jsonb().default({}).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	status: text().default('draft').notNull(),
	branchingConfig: jsonb("branching_config").default({"enabled":false,"threshold":4,"ratingStepId":null}).notNull(),
}, (table) => [
	index("idx_forms_active").using("btree", table.organizationId.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
	index("idx_forms_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_forms_organization_status").using("btree", table.organizationId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "forms_created_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "forms_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "forms_updated_by_fk"
		}).onDelete("set null"),
	check("chk_forms_status", sql`status = ANY (ARRAY['draft'::text, 'published'::text, 'archived'::text])`),
]);

export const questionTypes = pgTable("question_types", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	uniqueName: varchar("unique_name", { length: 50 }).notNull(),
	name: varchar({ length: 100 }).notNull(),
	category: varchar({ length: 30 }).notNull(),
	description: text(),
	inputComponent: varchar("input_component", { length: 50 }).notNull(),
	answerDataType: varchar("answer_data_type", { length: 20 }).notNull(),
	supportsMinLength: boolean("supports_min_length").default(false).notNull(),
	supportsMaxLength: boolean("supports_max_length").default(false).notNull(),
	supportsMinValue: boolean("supports_min_value").default(false).notNull(),
	supportsMaxValue: boolean("supports_max_value").default(false).notNull(),
	supportsPattern: boolean("supports_pattern").default(false).notNull(),
	supportsOptions: boolean("supports_options").default(false).notNull(),
	supportsFileTypes: boolean("supports_file_types").default(false).notNull(),
	supportsMaxFileSize: boolean("supports_max_file_size").default(false).notNull(),
	defaultMinValue: integer("default_min_value"),
	defaultMaxValue: integer("default_max_value"),
	isActive: boolean("is_active").default(true).notNull(),
	displayOrder: smallint("display_order").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	icon: varchar({ length: 50 }),
}, (table) => [
	index("idx_question_types_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	unique("question_types_unique_name_unique").on(table.uniqueName),
	check("question_types_answer_type_check", sql`(answer_data_type)::text = ANY ((ARRAY['text'::character varying, 'integer'::character varying, 'boolean'::character varying, 'decimal'::character varying, 'json'::character varying, 'url'::character varying])::text[])`),
	check("question_types_category_check", sql`(category)::text = ANY ((ARRAY['text'::character varying, 'rating'::character varying, 'choice'::character varying, 'media'::character varying, 'special'::character varying, 'input'::character varying])::text[])`),
]);

export const formQuestions = pgTable("form_questions", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	questionTypeId: text("question_type_id").notNull(),
	questionKey: varchar("question_key", { length: 50 }).notNull(),
	questionText: text("question_text").notNull(),
	placeholder: text(),
	helpText: text("help_text"),
	displayOrder: smallint("display_order").notNull(),
	isRequired: boolean("is_required").default(true).notNull(),
	minLength: integer("min_length"),
	maxLength: integer("max_length"),
	minValue: integer("min_value"),
	maxValue: integer("max_value"),
	validationPattern: text("validation_pattern"),
	allowedFileTypes: text("allowed_file_types").array(),
	maxFileSizeKb: integer("max_file_size_kb"),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedBy: text("updated_by"),
	scaleMinLabel: text("scale_min_label"),
	scaleMaxLabel: text("scale_max_label"),
	stepId: text("step_id"),
}, (table) => [
	index("idx_form_questions_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_form_questions_step_id").using("btree", table.stepId.asc().nullsLast().op("text_ops")),
	uniqueIndex("idx_form_questions_step_id_unique").using("btree", table.stepId.asc().nullsLast().op("text_ops")).where(sql`(step_id IS NOT NULL)`),
	index("idx_form_questions_type").using("btree", table.questionTypeId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.stepId],
			foreignColumns: [formSteps.id],
			name: "fk_form_questions_step_id"
		}).onUpdate("cascade").onDelete("cascade"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "form_questions_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.questionTypeId],
			foreignColumns: [questionTypes.id],
			name: "form_questions_type_fk"
		}).onDelete("restrict"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "form_questions_updated_by_fk"
		}).onDelete("set null"),
	check("form_questions_key_format", sql`(question_key)::text ~ '^[a-z][a-z0-9_]*$'::text`),
	check("form_questions_length_check", sql`(min_length IS NULL) OR (max_length IS NULL) OR (min_length <= max_length)`),
	check("form_questions_value_check", sql`(min_value IS NULL) OR (max_value IS NULL) OR (min_value <= max_value)`),
]);

export const questionOptions = pgTable("question_options", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	questionId: text("question_id").notNull(),
	optionValue: varchar("option_value", { length: 100 }).notNull(),
	optionLabel: text("option_label").notNull(),
	displayOrder: smallint("display_order").notNull(),
	isDefault: boolean("is_default").default(false).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: text("created_by").notNull(),
}, (table) => [
	index("idx_question_options_order").using("btree", table.questionId.asc().nullsLast().op("int2_ops"), table.displayOrder.asc().nullsLast().op("text_ops")),
	index("idx_question_options_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_question_options_question").using("btree", table.questionId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "question_options_created_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "question_options_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.questionId],
			foreignColumns: [formQuestions.id],
			name: "question_options_question_fk"
		}).onDelete("cascade"),
	unique("question_options_value_per_question_unique").on(table.questionId, table.optionValue),
	unique("question_options_order_per_question_unique").on(table.questionId, table.displayOrder),
]);

export const formQuestionResponses = pgTable("form_question_responses", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	submissionId: text("submission_id").notNull(),
	questionId: text("question_id").notNull(),
	answerText: text("answer_text"),
	answerInteger: integer("answer_integer"),
	answerBoolean: boolean("answer_boolean"),
	answerJson: jsonb("answer_json"),
	answerUrl: text("answer_url"),
	answeredAt: timestamp("answered_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedBy: text("updated_by"),
}, (table) => [
	index("idx_form_question_responses_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_form_question_responses_question").using("btree", table.questionId.asc().nullsLast().op("text_ops")),
	index("idx_form_question_responses_rating").using("btree", table.questionId.asc().nullsLast().op("int4_ops"), table.answerInteger.asc().nullsLast().op("int4_ops")).where(sql`(answer_integer IS NOT NULL)`),
	index("idx_form_question_responses_submission").using("btree", table.submissionId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "form_question_responses_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.questionId],
			foreignColumns: [formQuestions.id],
			name: "form_question_responses_question_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [formSubmissions.id],
			name: "form_question_responses_submission_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "form_question_responses_updated_by_fk"
		}).onDelete("set null"),
	unique("form_question_responses_unique").on(table.submissionId, table.questionId),
	check("form_question_responses_has_value", sql`(answer_text IS NOT NULL) OR (answer_integer IS NOT NULL) OR (answer_boolean IS NOT NULL) OR (answer_json IS NOT NULL) OR (answer_url IS NOT NULL)`),
]);

export const widgets = pgTable("widgets", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	createdBy: text("created_by").notNull(),
	name: text().notNull(),
	type: text().notNull(),
	theme: text().default('light').notNull(),
	showRatings: boolean("show_ratings").default(true).notNull(),
	showDates: boolean("show_dates").default(false).notNull(),
	showCompany: boolean("show_company").default(true).notNull(),
	showAvatar: boolean("show_avatar").default(true).notNull(),
	maxDisplay: smallint("max_display"),
	settings: jsonb().default({}).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedBy: text("updated_by"),
}, (table) => [
	index("idx_widgets_active").using("btree", table.organizationId.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
	index("idx_widgets_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "widgets_created_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "widgets_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "widgets_updated_by_fk"
		}).onDelete("set null"),
	check("widgets_theme_check", sql`theme = ANY (ARRAY['light'::text, 'dark'::text])`),
	check("widgets_type_check", sql`type = ANY (ARRAY['wall_of_love'::text, 'carousel'::text, 'single_quote'::text])`),
]);

export const testimonials = pgTable("testimonials", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	submissionId: text("submission_id"),
	status: text().default('pending').notNull(),
	content: text(),
	rating: smallint(),
	customerName: text("customer_name").notNull(),
	customerEmail: text("customer_email").notNull(),
	customerTitle: text("customer_title"),
	customerCompany: text("customer_company"),
	customerAvatarUrl: text("customer_avatar_url"),
	customerLinkedinUrl: text("customer_linkedin_url"),
	customerTwitterUrl: text("customer_twitter_url"),
	source: text().default('form').notNull(),
	sourceMetadata: jsonb("source_metadata"),
	approvedBy: text("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	rejectedBy: text("rejected_by"),
	rejectedAt: timestamp("rejected_at", { withTimezone: true, mode: 'string' }),
	rejectionReason: text("rejection_reason"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedBy: text("updated_by"),
}, (table) => [
	index("idx_testimonials_approved").using("btree", table.organizationId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("text_ops")).where(sql`(status = 'approved'::text)`),
	index("idx_testimonials_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_testimonials_status").using("btree", table.organizationId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("text_ops")),
	index("idx_testimonials_submission").using("btree", table.submissionId.asc().nullsLast().op("text_ops")).where(sql`(submission_id IS NOT NULL)`),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [users.id],
			name: "testimonials_approved_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "testimonials_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.rejectedBy],
			foreignColumns: [users.id],
			name: "testimonials_rejected_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [formSubmissions.id],
			name: "testimonials_submission_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "testimonials_updated_by_fk"
		}).onDelete("set null"),
	check("testimonials_email_format", sql`customer_email ~* '^.+@.+\..+$'::text`),
	check("testimonials_linkedin_url_format", sql`(customer_linkedin_url IS NULL) OR (customer_linkedin_url ~* '^https?://(www\.)?linkedin\.com/'::text)`),
	check("testimonials_rating_check", sql`(rating IS NULL) OR ((rating >= 1) AND (rating <= 5))`),
	check("testimonials_source_check", sql`source = ANY (ARRAY['form'::text, 'import'::text, 'manual'::text])`),
	check("testimonials_status_check", sql`status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text])`),
	check("testimonials_twitter_url_format", sql`(customer_twitter_url IS NULL) OR (customer_twitter_url ~* '^https?://(www\.)?(twitter\.com|x\.com)/'::text)`),
]);

export const widgetTestimonials = pgTable("widget_testimonials", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	widgetId: text("widget_id").notNull(),
	testimonialId: text("testimonial_id").notNull(),
	displayOrder: smallint("display_order").notNull(),
	isFeatured: boolean("is_featured").default(false).notNull(),
	addedAt: timestamp("added_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	addedBy: text("added_by"),
}, (table) => [
	index("idx_widget_testimonials_order").using("btree", table.widgetId.asc().nullsLast().op("int2_ops"), table.displayOrder.asc().nullsLast().op("text_ops")),
	index("idx_widget_testimonials_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_widget_testimonials_testimonial").using("btree", table.testimonialId.asc().nullsLast().op("text_ops")),
	index("idx_widget_testimonials_widget").using("btree", table.widgetId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.addedBy],
			foreignColumns: [users.id],
			name: "widget_testimonials_added_by_fk"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "widget_testimonials_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.testimonialId],
			foreignColumns: [testimonials.id],
			name: "widget_testimonials_testimonial_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.widgetId],
			foreignColumns: [widgets.id],
			name: "widget_testimonials_widget_fk"
		}).onDelete("cascade"),
	unique("widget_testimonials_unique").on(table.widgetId, table.testimonialId),
	unique("widget_testimonials_order_unique").on(table.widgetId, table.displayOrder),
]);

export const planQuestionTypes = pgTable("plan_question_types", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	planId: text("plan_id").notNull(),
	questionTypeId: text("question_type_id").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: text("created_by"),
	updatedBy: text("updated_by"),
}, (table) => [
	index("idx_plan_question_types_plan_id").using("btree", table.planId.asc().nullsLast().op("text_ops")),
	index("idx_plan_question_types_question_type_id").using("btree", table.questionTypeId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "plan_question_types_created_by_fk"
		}).onUpdate("cascade").onDelete("set null"),
	foreignKey({
			columns: [table.planId],
			foreignColumns: [plans.id],
			name: "plan_question_types_plan_fk"
		}).onUpdate("cascade").onDelete("cascade"),
	foreignKey({
			columns: [table.questionTypeId],
			foreignColumns: [questionTypes.id],
			name: "plan_question_types_question_type_fk"
		}).onUpdate("cascade").onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "plan_question_types_updated_by_fk"
		}).onUpdate("cascade").onDelete("set null"),
	unique("plan_question_types_unique").on(table.planId, table.questionTypeId),
]);

export const contacts = pgTable("contacts", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	email: text().notNull(),
	emailVerified: boolean("email_verified").default(false).notNull(),
	name: text(),
	avatarUrl: text("avatar_url"),
	jobTitle: text("job_title"),
	companyName: text("company_name"),
	companyWebsite: text("company_website"),
	linkedinUrl: text("linkedin_url"),
	twitterUrl: text("twitter_url"),
	source: text().default('form_submission').notNull(),
	sourceFormId: text("source_form_id"),
	firstSeenAt: timestamp("first_seen_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	lastSeenAt: timestamp("last_seen_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	submissionCount: integer("submission_count").default(1).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_contacts_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_contacts_last_seen_at").using("btree", table.lastSeenAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_contacts_organization_id").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "fk_contacts_organization_id"
		}).onUpdate("cascade").onDelete("cascade"),
	foreignKey({
			columns: [table.sourceFormId],
			foreignColumns: [forms.id],
			name: "fk_contacts_source_form_id"
		}).onUpdate("cascade").onDelete("set null"),
	unique("contacts_org_email_unique").on(table.organizationId, table.email),
	check("contacts_source_check", sql`source = ANY (ARRAY['form_submission'::text, 'import'::text, 'manual'::text])`),
]);

export const formSubmissions = pgTable("form_submissions", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	formId: text("form_id").notNull(),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedBy: text("updated_by"),
	contactId: text("contact_id"),
}, (table) => [
	index("idx_form_submissions_contact_id").using("btree", table.contactId.asc().nullsLast().op("text_ops")),
	index("idx_form_submissions_form").using("btree", table.formId.asc().nullsLast().op("text_ops")),
	index("idx_form_submissions_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_form_submissions_submitted").using("btree", table.organizationId.asc().nullsLast().op("text_ops"), table.submittedAt.desc().nullsFirst().op("text_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "fk_form_submissions_contact_id"
		}).onUpdate("cascade").onDelete("set null"),
	foreignKey({
			columns: [table.formId],
			foreignColumns: [forms.id],
			name: "form_submissions_form_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "form_submissions_org_fk"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "form_submissions_updated_by_fk"
		}).onDelete("set null"),
]);

export const mediaEntityTypes = pgTable("media_entity_types", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	code: text().notNull(),
	displayName: text("display_name").notNull(),
	description: text().notNull(),
	targetTable: text("target_table").notNull(),
	targetColumn: text("target_column").default('id').notNull(),
	allowedMimeTypes: text("allowed_mime_types").array().notNull(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	maxFileSizeBytes: bigint("max_file_size_bytes", { mode: "number" }).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: text("created_by"),
	updatedBy: text("updated_by"),
}, (table) => [
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "media_entity_types_created_by_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "media_entity_types_updated_by_fkey"
		}),
	unique("media_entity_types_code_key").on(table.code),
]);

export const formSteps = pgTable("form_steps", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	stepType: text("step_type").notNull(),
	stepOrder: smallint("step_order").notNull(),
	content: jsonb().default({}).notNull(),
	tips: text().array().default([""]),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: text("created_by"),
	updatedBy: text("updated_by"),
	flowMembership: text("flow_membership").default('shared').notNull(),
	flowId: text("flow_id").notNull(),
}, (table) => [
	index("idx_form_steps_flow_id").using("btree", table.flowId.asc().nullsLast().op("text_ops")),
	index("idx_form_steps_flow_order").using("btree", table.flowId.asc().nullsLast().op("text_ops"), table.stepOrder.asc().nullsLast().op("text_ops")),
	index("idx_form_steps_organization_id").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "fk_form_steps_created_by"
		}).onUpdate("cascade").onDelete("set null"),
	foreignKey({
			columns: [table.flowId],
			foreignColumns: [flows.id],
			name: "fk_form_steps_flow_id"
		}).onUpdate("cascade").onDelete("cascade"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "fk_form_steps_organization_id"
		}).onUpdate("cascade").onDelete("restrict"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "fk_form_steps_updated_by"
		}).onUpdate("cascade").onDelete("set null"),
	unique("form_steps_flow_order_unique").on(table.stepOrder, table.flowId),
	check("form_steps_step_type_check", sql`step_type = ANY (ARRAY['welcome'::text, 'question'::text, 'rating'::text, 'consent'::text, 'contact_info'::text, 'reward'::text, 'thank_you'::text])`),
]);

export const media = pgTable("media", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	filename: text().notNull(),
	mimeType: text("mime_type").notNull(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	fileSizeBytes: bigint("file_size_bytes", { mode: "number" }).notNull(),
	storageProvider: text("storage_provider").default('aws_s3').notNull(),
	storageBucket: text("storage_bucket").notNull(),
	storagePath: text("storage_path").notNull(),
	storageRegion: text("storage_region"),
	entityType: text("entity_type").notNull(),
	entityId: text("entity_id"),
	status: text().default('pending').notNull(),
	errorMessage: text("error_message"),
	processingMetadata: jsonb("processing_metadata").default({}).notNull(),
	width: integer(),
	height: integer(),
	durationSeconds: numeric("duration_seconds"),
	thumbnailPath: text("thumbnail_path"),
	uploadedBy: text("uploaded_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_media_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_media_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("idx_media_organization_id").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_media_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	uniqueIndex("idx_media_storage_path").using("btree", table.storageBucket.asc().nullsLast().op("text_ops"), table.storagePath.asc().nullsLast().op("text_ops")),
	index("idx_media_uploaded_by").using("btree", table.uploadedBy.asc().nullsLast().op("text_ops")).where(sql`(uploaded_by IS NOT NULL)`),
	foreignKey({
			columns: [table.entityType],
			foreignColumns: [mediaEntityTypes.code],
			name: "fk_media_entity_type"
		}).onUpdate("cascade").onDelete("restrict"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "fk_media_organization_id"
		}).onUpdate("cascade").onDelete("cascade"),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [users.id],
			name: "fk_media_uploaded_by"
		}).onUpdate("cascade").onDelete("set null"),
	check("chk_media_duration_non_negative", sql`(duration_seconds IS NULL) OR (duration_seconds >= (0)::numeric)`),
	check("chk_media_file_size_positive", sql`file_size_bytes > 0`),
	check("chk_media_height_positive", sql`(height IS NULL) OR (height > 0)`),
	check("chk_media_status", sql`status = ANY (ARRAY['pending'::text, 'processing'::text, 'ready'::text, 'failed'::text, 'deleted'::text])`),
	check("chk_media_width_positive", sql`(width IS NULL) OR (width > 0)`),
]);

export const formAnalyticsEvents = pgTable("form_analytics_events", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	organizationId: text("organization_id").notNull(),
	formId: text("form_id").notNull(),
	sessionId: text("session_id").notNull(),
	eventType: text("event_type").notNull(),
	stepIndex: integer("step_index"),
	stepId: text("step_id"),
	stepType: text("step_type"),
	eventData: jsonb("event_data").default({}).notNull(),
	userAgent: text("user_agent"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_form_analytics_event_type").using("btree", table.organizationId.asc().nullsLast().op("text_ops"), table.eventType.asc().nullsLast().op("text_ops")),
	index("idx_form_analytics_form").using("btree", table.formId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("text_ops")),
	index("idx_form_analytics_org").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	index("idx_form_analytics_session").using("btree", table.sessionId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.formId],
			foreignColumns: [forms.id],
			name: "form_analytics_events_form_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "form_analytics_events_organization_id_fkey"
		}).onDelete("cascade"),
	check("form_analytics_events_event_type_check", sql`event_type = ANY (ARRAY['form_started'::text, 'step_completed'::text, 'step_skipped'::text, 'form_submitted'::text, 'form_abandoned'::text, 'form_resumed'::text])`),
]);

export const flows = pgTable("flows", {
	id: text().default(sql`generate_nanoid_12()`).primaryKey().notNull(),
	formId: text("form_id").notNull(),
	organizationId: text("organization_id").notNull(),
	name: text().notNull(),
	flowType: text("flow_type").notNull(),
	displayOrder: smallint("display_order").default(0).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	branchQuestionId: text("branch_question_id"),
	branchField: text("branch_field"),
	branchOperator: text("branch_operator"),
	branchValue: jsonb("branch_value"),
	isPrimary: boolean("is_primary").default(false).notNull(),
}, (table) => [
	index("idx_flows_branch_question_id").using("btree", table.branchQuestionId.asc().nullsLast().op("text_ops")).where(sql`(branch_question_id IS NOT NULL)`),
	index("idx_flows_form_id").using("btree", table.formId.asc().nullsLast().op("text_ops")),
	index("idx_flows_form_order").using("btree", table.formId.asc().nullsLast().op("int2_ops"), table.displayOrder.asc().nullsLast().op("text_ops")),
	index("idx_flows_organization_id").using("btree", table.organizationId.asc().nullsLast().op("text_ops")),
	uniqueIndex("idx_flows_primary_per_form").using("btree", table.formId.asc().nullsLast().op("text_ops")).where(sql`(is_primary = true)`),
	foreignKey({
			columns: [table.branchQuestionId],
			foreignColumns: [formQuestions.id],
			name: "fk_flows_branch_question"
		}).onUpdate("cascade").onDelete("restrict"),
	foreignKey({
			columns: [table.formId],
			foreignColumns: [forms.id],
			name: "fk_flows_form_id"
		}).onUpdate("cascade").onDelete("cascade"),
	foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organizations.id],
			name: "fk_flows_organization_id"
		}).onUpdate("cascade").onDelete("restrict"),
	unique("flows_form_name_unique").on(table.formId, table.name),
	check("chk_flows_branch_field", sql`(branch_field IS NULL) OR (branch_field = ANY (ARRAY['answer_integer'::text, 'answer_text'::text, 'answer_boolean'::text, 'answer_json'::text]))`),
	check("chk_flows_branch_operator", sql`(branch_operator IS NULL) OR (branch_operator = ANY (ARRAY['equals'::text, 'not_equals'::text, 'greater_than'::text, 'greater_than_or_equal_to'::text, 'less_than'::text, 'less_than_or_equal_to'::text, 'between'::text, 'is_one_of'::text, 'contains'::text, 'is_empty'::text]))`),
	check("chk_flows_branch_requires_conditions", sql`CHECK (
CASE
    WHEN (flow_type = 'branch'::text) THEN ((branch_question_id IS NOT NULL) AND (branch_operator IS NOT NULL))
    ELSE true
END)`),
	check("chk_flows_condition_completeness", sql`((flow_type = 'shared'::text) AND (branch_question_id IS NULL) AND (branch_field IS NULL) AND (branch_operator IS NULL) AND (branch_value IS NULL)) OR ((flow_type = 'branch'::text) AND (branch_question_id IS NOT NULL) AND (branch_field IS NOT NULL) AND (branch_operator IS NOT NULL))`),
	check("chk_flows_primary_no_branch", sql`(NOT is_primary) OR ((branch_question_id IS NULL) AND (branch_operator IS NULL) AND (branch_value IS NULL))`),
	check("flows_flow_type_check", sql`flow_type = ANY (ARRAY['shared'::text, 'branch'::text])`),
]);
